{"Id":21,"Title":"JavaScript设计模式--- call 实现继承","Slug":"javascript-call","Text":"1.JScript官方解释： \n---\n**call** 方法 \n\n调用一个对象的一个方法，以另一个对象替换当前对象。 \n\n**call([thisObj[,arg1[, arg2[,   [,.argN]]]]]) **\n\n参数 thisObj 可选项。将被用作当前对象的对象。 \n\narg1, arg2,  , argN 可选项。将被传递方法参数序列。 \n\n**说明** \n\ncall 方法可以用来代替另一个对象调用一个方法。\n\ncall 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 \n\n如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 \n\n要求 \n版本 5.5 \n\n2.我的理解 \n---\n以obj1.method1.call(obj2,argument1,argument2,...)为例： \n\ncall方法的调用者：一个对象的方法（在js里面方法/函数也是对象），\n\n调用者为，obj1.method1 \n\ncall方法的参数：一个新对象（obj2），这个对象的作用是“拦截”对象obj1，来运行本来属于obj1的method方法；而 argument1,argument2,...就是给method传递参数了 \ncall方法的结果：obj1.method1.call(obj2,argument1,argument2,...)等价于： \nobj2.method1(argument1,argument2,...) \ncall方法的作用：obj1.method方法得到重用、共享，有new的特效，实现继承 \n最简单的理解： \n关于call，把隐藏的第一个参数显示化。因为通常一个方法x的调用，会有一个额外的隐藏参数，就是x所属的对象，如果没有所属，则为global（如window）对象，并在函数内可以用this关键字访问之。 \n\n3.一些实例 \n---\n（1）方法得到重用、共享 \n\n代码\n\n\n    function show()\n    {\n    var id = \"1\"\n    this.h = function()\n    {\n    alert(id);\n    }\n    }\n    //var a=new show();\n    var a={};\n    var b={};\n    show.call(a);\n    show.call(b);\n    a.h();\n    b.h();\n    \n-\n\n    function show()\n    {\n      var id=\"1\";\n      this.h=function(){\n        alert(id);\n      }\n    }\n    //var a=new show();\n    var a={};\n    var b={};\n    show.call(a);\n    show.call(b);\n    a.h();\n    b.h()\n    \n这样一来是不是方法重用呢？ \n\n（2）取代new \n\n    function show(){\n        var id=\"1\";\n        this.h=function(){\n            alert(id);\n        }\n    }\n    //var a=new show();\n    var a={};\n    show.call(a);\n    a.h();\n -\n \n\u0009function show(){\n    \u0009var id=\"1\";\n        this.h=function(){\n        \u0009alert(id);\n        }\n    }\n    //var a=new show();\n    var a={};\n    show.call(a);\n    a.h();\n这个例子看视奇怪，其实，不必惊讶！ \n\nshow函数其实可以看成window.show，那么show.call(a)就是window.call(a)! \n\n（3）实现继承 \n\njs实现继承一般是用prototype,这不是本文讨论的主题，但是call也可以用来实现继承，如 \n\n    function show1(){  \n        var id=\"1\";  \n        this.h=function(){  \n            alert(id);  \n        }  \n    }  \n    function show2(){  \n        show1.call(this);  \n    }  \n    var s={};  \n    show2.call(s); //new的取代  \n    s.h();  \n-\n\n    function show1(){ \n    \u0009var id=\"1\"; \n        this.h=function(){\n        \u0009alert(id);\n        } \n    } \n    function show2(){\n    \u0009show1.call(this);\n    } \n    var s={}; \n    show2.call(s); \n    //new的取代 s.h(); \n    \n这样一来是不是达到继承的目的！如果要实现多重继承则： \n  \n    function show1(){  \n        var id=\"1\";  \n        this.h=function(){  \n            alert(id);  \n        }  \n    }  \n    function show2(){  \n        show1.call(this);  \n    }  \n    function show3(){  \n        show2.call(this);  \n    }  \n    var s={};  \n    show3.call(s);  \n    s.h();  \n-\n\n\u0009function show1(){\n    \u0009var id=\"1\"; this.h=function(){\n        \u0009alert(id);\n        }\n    } \n    function show2(){\n    \u0009show1.call(this); \n    } \n    function show3(){ \n    \u0009show2.call(this); \n    } \n    var s={}; \n    show3.call(s);\n    s.h();\n是不是能达到prototype的目的。 \n\n当然，从一定的角度上考虑，这样的继承，是有问题的，直接在类函数体里面定义成员方法，将导致每个实例都有副本，重复占用了内存。","Tags":["javascript"],"CreateTime":1415967534,"EditTime":1415974815,"UpdateTime":1415967534,"IsComment":true,"IsLinked":false,"AuthorId":5,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":2}